//#include <stdio.h>
//#include <stdbool.h>
//
//int main(){
//    int c, nwhite, nother;
//    int ndigit[10];
//    nwhite = nother = 0;
//    for (int i=0; i<10; i++){
//        ndigit[i] = 0;
//    }
//    while((c = getchar()) != EOF){
//        if (c >= '0' && c <= "0"){
//            ndigit[c-'0']++;
//        }
//        else if (c == ' ' || c == '\n' || c == "\t"){
//            nwhite++;
//        }
//        else{
//            nother++;
//        }
//    }
//    printf("цифры=")
//    for (int i =0; i < 10; i++){
//        printf("%d ", ndigit[i]);
//    }
//    printf(", пробельные стмволы = %d, остальные символы = %d", nwhite, nother)
//    return 0;
//}
//
//#include <stdio.h>
//#define MAXLINE 1000 //Максимальный размер строки
//
//int getline(char line[], int max);
//int strindex(char source[], char searchfor[0]);
//
//char pattern[] = "ouid";
//
//int power(int base, int n) {
//    int p;
//    p = 1;
//    for (int i = 0; i <= n; i++) {
//        p *= base;
//
//        return 0;
//    }
//}
//int main(){
//
//    char line[MAXLINE];
//    int found = 0;
//    while(getline(line, MAXLINE)>0){
//        if(strindex(line, pattern) >= 0){
//            printf("%s", line);
//            found++;
//        }
//    }
//    return found;
//}
//
//int getline(char s[], int lim){
//    int c;
//    while (--lim>0 && (c == getchar()) != EOF && c!= '\n'){
//        s[i++] = c;
//    }
//    if(c == "\n"){
//        s[i++] = c;
//    }
//    s[i] = '\0';
//    return 0;
//}
//
//int strindex(char s[], char t[]){
//    int k;
//    for (int i=0; s[i] != '\0'; i++){
//        for(int j=i, k=0; t[k] != '\0' && s[j] == t[k]; j++, k++){
//            if(k>0 && t[k] == '\0'){
//                return i;
//            }
//        }
//    }
//    return -1;
//}

#include <stdio.h>

//int fact(int n){
//    if(n==1){
//        return n;
//    }
//    else{
//        return n* fact(n-1);
//    }
//}
//
//int main(){
//    printf("%d", fact(5));
//}

#include <stdio.h>
#include <sstream>
#include <string>
//int matrix(int n) {
//    for (int i = 1; i <= n; i++) {
//        int counter = 0;
//        while(counter != n){
//            printf("%d", 1);
//            counter += 1;
//        }
//        printf("\n");
//    }
//}

#include <stdio.h>
#include <stdlib.h>

//#1
//#include <iostream>
//
//// Функция для создания единичной матрицы
//int** createIdentityMatrix(int size) {
//    int** matrix = new int*[size];
//    for(int i = 0; i < size; ++i) {
//        matrix[i] = new int[size];
//        for(int j = 0; j < size; ++j) {
//            matrix[i][j] = 1;
//        }
//    }
//    return matrix;
//}
//
//// Функция для освобождения памяти, выделенной под матрицу
//void deleteMatrix(int** matrix, int size) {
//    for(int i = 0; i < size; ++i) {
//        delete[] matrix[i];
//    }
//    delete[] matrix;
//}
//
//int main() {
//    int size = 4; // Задайте нужный размер матрицы
//
//    int** identityMatrix = createIdentityMatrix(size);
//
//    // Вывод матрицы
//    for(int i = 0; i < size; ++i) {
//        for(int j = 0; j < size; ++j) {
//            std::cout << identityMatrix[i][j] << " ";
//        }
//        std::cout << std::endl;
//    }
//
//    deleteMatrix(identityMatrix, size); // Освобождаем память
//
//    return 0;
//}
//
//#2
//#include <iostream>
//#include <vector>
//#include <windows.h>
//
//// Тип для представления матрицы
//using Matrix = std::vector<std::vector<int>>;
//
//// Функция для проверки, можно ли выполнить операцию с двумя матрицами
//bool canOperate(const Matrix& A, const Matrix& B) {
//    return A.size() == B.size() && A[0].size() == B[0].size();
//}
//
//// Функция для сложения двух матриц
//Matrix addMatrices(const Matrix& A, const Matrix& B) {
//    if (!canOperate(A, B)) {
//        throw std::invalid_argument("Невозможно сложить матрицы разных размеров.");
//    }
//
//    Matrix result(A.size(), std::vector<int>(A[0].size()));
//
//    for (size_t i = 0; i < A.size(); ++i) {
//        for (size_t j = 0; j < A[0].size(); ++j) {
//            result[i][j] = A[i][j] + B[i][j];
//        }
//    }
//
//    return result;
//}
//
//// Функция для вычитания одной матрицы из другой
//Matrix subtractMatrices(const Matrix& A, const Matrix& B) {
//    if (!canOperate(A, B)) {
//        throw std::invalid_argument("Невозможно вычесть матрицы разных размеров.");
//    }
//
//    Matrix result(A.size(), std::vector<int>(A[0].size()));
//
//    for (size_t i = 0; i < A.size(); ++i) {
//        for (size_t j = 0; j < A[0].size(); ++j) {
//            result[i][j] = A[i][j] - B[i][j];
//        }
//    }
//
//    return result;
//}
//
//// Функция для умножения матрицы на число
//Matrix multiplyMatrixByScalar(const Matrix& A, int scalar) {
//    Matrix result(A.size(), std::vector<int>(A[0].size()));
//
//    for (size_t i = 0; i < A.size(); ++i) {
//        for (size_t j = 0; j < A[0].size(); ++j) {
//            result[i][j] = A[i][j] * scalar;
//        }
//    }
//
//    return result;
//}
//
//// Функция для умножения двух матриц
//Matrix multiplyMatrices(const Matrix& A, const Matrix& B) {
//    if (A[0].size() != B.size()) {
//        throw std::invalid_argument("Невозможно умножить эти матрицы.");
//    }
//
//    Matrix result(A.size(), std::vector<int>(B[0].size()));
//
//    for (size_t i = 0; i < A.size(); ++i) {
//        for (size_t j = 0; j < B[0].size(); ++j) {
//            for (size_t k = 0; k < B.size(); ++k) {
//                result[i][j] += A[i][k] * B[k][j];
//            }
//        }
//    }
//
//    return result;
//}
//
//// Функция для получения транспонированной матрицы
//Matrix transposeMatrix(const Matrix& A) {
//    Matrix result(A[0].size(), std::vector<int>(A.size()));
//
//    for (size_t i = 0; i < A.size(); ++i) {
//        for (size_t j = 0; j < A[0].size(); ++j) {
//            result[j][i] = A[i][j];
//        }
//    }
//
//    return result;
//}
//
//// Функция для проверки равенства двух матриц
//bool areMatricesEqual(const Matrix& A, const Matrix& B) {
//    if (!canOperate(A, B)) {
//        return false;
//    }
//
//    for (size_t i = 0; i < A.size(); ++i) {
//        for (size_t j = 0; j < A[0].size(); ++j) {
//            if (A[i][j] != B[i][j]) {
//                return false;
//            }
//        }
//    }
//
//    return true;
//}
//
//int main() {
//    // Пример использования функций
//    SetConsoleOutputCP(CP_UTF8);
//
//    Matrix A = {{1, 2}, {3, 4}};
//    Matrix B = {{5, 6}, {7, 8}};
//
//    try {
//        Matrix C = addMatrices(A, B);
//        std::cout << "Результат сложения:" << std::endl;
//        for (const auto& row : C) {
//            for (int elem : row) {
//                std::cout << elem << " ";
//            }
//            std::cout << std::endl;
//        }
//
//        Matrix D = subtractMatrices(A, B);
//        std::cout << "Результат вычитания:" << std::endl;
//        for (const auto& row : D) {
//            for (int elem : row) {
//                std::cout << elem << " ";
//            }
//            std::cout << std::endl;
//        }
//
//        Matrix E = multiplyMatrixByScalar(A, 3);
//        std::cout << "Результат умножения на число:" << std::endl;
//        for (const auto& row : E) {
//            for (int elem : row) {
//                std::cout << elem << " ";
//            }
//            std::cout << std::endl;
//        }
//
//        Matrix F = {{1, 2, 3}, {4, 5, 6}};
//        Matrix G = {{7, 8}, {9, 10}, {11, 12}};
//        Matrix H = multiplyMatrices(F, G);
//        std::cout << "Результат умножения матриц:" << std::endl;
//        for (const auto& row : H) {
//            for (int elem : row) {
//                std::cout << elem << " ";
//            }
//            std::cout << std::endl;
//        }
//
//        Matrix I = {{1, 2}, {3, 4}};
//        Matrix J = transposeMatrix(I);
//        std::cout << "Результат транспонирования:" << std::endl;
//        for (const auto& row : J) {
//            for (int elem : row) {
//                std::cout << elem << " ";
//            }
//            std::cout << std::endl;
//        }
//
//        Matrix K = {{1, 2}, {3, 4}};
//        Matrix L = {{1, 2}, {3, 4}};
//        bool equal = areMatricesEqual(K, L);
//        std::cout << "Матрицы равны: " << (equal ? "Да" : "Нет") << std::endl;
//
//    } catch (const std::invalid_argument& e) {
//        std::cerr << e.what() << std::endl;
//    }
//
//    return 0;
//}
//
//#3
//#include <iostream>
//#include <vector>
//#include <algorithm>
//#include <windows.h>
//
//std::vector<int> sortArray(const std::vector<int>& arr, bool ascending) {
//    std::vector<int> sortedArr = arr;  // Создаем копию входного массива
//
//    if (ascending) {
//        std::sort(sortedArr.begin(), sortedArr.end());
//    } else {
//        std::sort(sortedArr.rbegin(), sortedArr.rend());  // Сортировка в обратном порядке
//    }
//
//    return sortedArr;
//}
//
//int main() {
//    SetConsoleOutputCP(CP_UTF8);
//    std::vector<int> input = {5, 2, 7, 1, 9, 3};
//    bool ascending = true;
//
//    std::vector<int> result = sortArray(input, ascending);
//
//    std::cout << "Отсортированный массив: ";
//    for (int num : result) {
//        std::cout << num << " ";
//    }
//    std::cout << std::endl;
//
//    return 0;
//}

//#4
//#include <iostream>
//#include <windows.h>
//
//void printNumbers(int n) {
//    if (n > 0) {
//        printNumbers(n - 1);
//        std::cout << n << " ";
//    }
//}
//
//int main() {
//    SetConsoleOutputCP(CP_UTF8);
//
//    int n;
//    std::cout << "Введите натуральное число n: ";
//    std::cin >> n;
//
//    if (n < 1) {
//        std::cout << "Число должно быть натуральным." << std::endl;
//        return 1;
//    }
//
//    std::cout << "Числа от 1 до " << n << ":\n";
//    printNumbers(n);
//    std::cout << std::endl;
//
//    return 0;
//}

//#5(перебор)
//#include <iostream>
//#include <vector>
//#include <ctime>
//#include <windows.h>
//
//bool linearSearch(const std::vector<int>& arr, int target, size_t index = 0) {
//    if (index >= arr.size()) {
//        return false; // Если дошли до конца массива, элемент не найден.
//    }
//
//    if (arr[index] == target) {
//        return true; // Если элемент найден, возвращаем true.
//    }
//
//    return linearSearch(arr, target, index + 1); // Иначе продолжаем поиск в следующем элементе.
//}
//
//int main() {
//    SetConsoleOutputCP(CP_UTF8);
//    const int size = 100000000; // Размер массива
//    std::vector<int> arr(size);
//
//    // Заполняем массив случайными числами
//    for (int i = 0; i < size; ++i) {
//        arr[i] = rand() % 1000000;
//    }
//
//    int target = 42; // Элемент, который будем искать
//
//    // Замеряем время выполнения перебора
//    clock_t start = clock();
//    bool found = linearSearch(arr, target);
//    clock_t end = clock();
//
//    double linearSearchTime = double(end - start) / CLOCKS_PER_SEC;
//
//    std::cout << "Результат перебора: " << (found ? "Элемент найден" : "Элемент не найден") << std::endl;
//    std::cout << "Время выполнения перебора: " << linearSearchTime << " секунд" << std::endl;
//
//    return 0;
//}

//#5(бинарный поиск)
//#include <iostream>
//#include <vector>
//#include <ctime>
//#include <algorithm>
//#include <windows.h>
//
//bool binarySearch(const std::vector<int>& arr, int target, int left, int right) {
//    if (left > right) {
//        return false;
//    }
//
//    int mid = left + (right - left) / 2;
//
//    if (arr[mid] == target) {
//        return true;
//    }
//
//    if (arr[mid] < target) {
//        return binarySearch(arr, target, mid + 1, right);
//    } else {
//        return binarySearch(arr, target, left, mid - 1);
//    }
//}
//
//int main() {
//    SetConsoleOutputCP(CP_UTF8);
//
//    const int size = 100000000;
//    std::vector<int> arr(size);
//
//    for (int i = 0; i < size; ++i) {
//        arr[i] = rand() % 1000000;
//    }
//
//    int target = 42;
//
//    std::sort(arr.begin(), arr.end());
//
//    clock_t start = clock();
//    bool found = binarySearch(arr, target, 0, size - 1);
//    clock_t end = clock();
//
//    double binarySearchTime = double(end - start) / CLOCKS_PER_SEC;
//
//    std::cout << "Результат бинарного поиска: " << (found ? "Элемент найден" : "Элемент не найден") << std::endl;
//    std::cout << "Время выполнения бинарного поиска: " << binarySearchTime << " секунд" << std::endl;
//
//    return 0;
//}

//#6
//#include <iostream>
//#include <cmath>
//#include <windows.h>
//
//double equation(double x) {
//    return cos(pow(x, 5)) + pow(x, 4) - 345.3 * x - 23;
//}
//
//double findRoot(double a, double b, double epsilon) {
//    double c = (a + b) / 2;
//    if (fabs(b - a) < epsilon)
//        return c;
//    if (equation(c) == 0)
//        return c;
//    if (equation(c) * equation(a) < 0)
//        return findRoot(a, c, epsilon);
//    else
//        return findRoot(c, b, epsilon);
//}
//
//int main() {
//    SetConsoleOutputCP(CP_UTF8);
//    double a = 0;
//    double b = 10;
//    double epsilon = 0.001;
//
//    double root = findRoot(a, b, epsilon);
//
//    std::cout << "Корень уравнения: " << root << std::endl;
//
//    return 0;
//}

//#7
//
//#include <iostream>
//#include <vector>
//#include <cmath>
//#include <windows.h>
//
//int findClosestToAverage(const std::vector<int>& arr) {
//    int sum = 0;
//    for (int num : arr) {
//        sum += num;
//    }
//
//    double average = static_cast<double>(sum) / arr.size();
//    int closest = arr[0];
//    int diff = std::abs(arr[0] - average);
//
//    for (int num : arr) {
//        if (std::abs(num - average) < diff) {
//            closest = num;
//            diff = std::abs(num - average);
//        }
//    }
//
//    return closest;
//}
//
//int main() {
//    SetConsoleOutputCP(CP_UTF8);
//
//    std::vector<int> arr = {1, 4, 6, 8, 10, 12}; // Пример массива
//
//    int closest = findClosestToAverage(arr);
//
//    std::cout << "Элемент, наиболее близкий к среднему значению: " << closest << std::endl;
//
//    return 0;
//}

//#8
//#include <iostream>
//#include <vector>
//#include <unordered_set>
//#include <windows.h>
//
//bool hasDuplicates(const std::vector<int>& arr) {
//    std::unordered_set<int> uniqueElements;
//
//    for (int num : arr) {
//        if (uniqueElements.find(num) != uniqueElements.end()) {
//            return true; // Нашли дубликат
//        }
//        uniqueElements.insert(num);
//    }
//
//    return false; // Нет дубликатов
//}
//
//int main() {
//    SetConsoleOutputCP(CP_UTF8);
//
//    std::vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 8}; // Пример массива с дубликатом
//
//    bool hasDuplicatesResult = hasDuplicates(arr);
//
//    if (hasDuplicatesResult) {
//        std::cout << "В массиве есть дубликаты." << std::endl;
//    } else {
//        std::cout << "В массиве нет дубликатов." << std::endl;
//    }
//
//    return 0;
//}

//#9
//#include <iostream>
//#include <vector>
//#include <windows.h>
//
//int countConsecutiveEquals(const std::vector<int>& arr) {
//    int count = 0;
//    for (size_t i = 1; i < arr.size(); ++i) {
//        if (arr[i] == arr[i - 1]) {
//            count++;
//        }
//    }
//    return count;
//}
//
//int main() {
//    SetConsoleOutputCP(CP_UTF8);
//
//    std::vector<int> arr = {1, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5}; // Пример массива
//
//    int consecutiveEqualsCount = countConsecutiveEquals(arr);
//
//    std::cout << "Количество последовательных равных элементов: " << consecutiveEqualsCount << std::endl;
//
//    return 0;
//}

//#10
//#include <iostream>
//#include <vector>
//#include <cmath>
//#include <windows.h>
//
//void changeSignOfMaxAbsolute(std::vector<int>& arr) {
//    int maxAbs = std::abs(arr[0]);
//    size_t maxIndex = 0;
//
//    for (size_t i = 1; i < arr.size(); ++i) {
//        if (std::abs(arr[i]) > maxAbs) {
//            maxAbs = std::abs(arr[i]);
//            maxIndex = i;
//        }
//    }
//
//    arr[maxIndex] = -arr[maxIndex];
//}
//
//int main() {
//    SetConsoleOutputCP(CP_UTF8);
//
//    std::vector<int> arr = {-2, 5, 7, -10, 3};
//
//    changeSignOfMaxAbsolute(arr);
//
//    std::cout << "Измененный массив: ";
//    for (int num : arr) {
//        std::cout << num << " ";
//    }
//    std::cout << std::endl;
//
//    return 0;
//}

//#11
//
//#include <iostream>
//#include <vector>
//#include <windows.h>
//
//std::vector<int> mergeArrays(const std::vector<int>& arr1, const std::vector<int>& arr2) {
//    std::vector<int> merged;
//    size_t i = 0, j = 0;
//
//    while (i < arr1.size() && j < arr2.size()) {
//        if (arr1[i] <= arr2[j]) {
//            merged.push_back(arr1[i]);
//            i++;
//        } else {
//            merged.push_back(arr2[j]);
//            j++;
//        }
//    }
//
//    while (i < arr1.size()) {
//        merged.push_back(arr1[i]);
//        i++;
//    }
//
//    while (j < arr2.size()) {
//        merged.push_back(arr2[j]);
//        j++;
//    }
//
//    return merged;
//}
//
//int main() {
//    SetConsoleOutputCP(CP_UTF8);
//
//    std::vector<int> arr1 = {1, 3, 5, 7, 9};
//    std::vector<int> arr2 = {2, 4, 6, 8, 10};
//
//    std::vector<int> merged = mergeArrays(arr1, arr2);
//
//    std::cout << "Объединенный массив: ";
//    for (int num : merged) {
//        std::cout << num << " ";
//    }
//    std::cout << std::endl;
//
//    return 0;
//}

//#12
//#include <iostream>
//#include <vector>
//#include <windows.h>
//
//void selectionSort(std::vector<int>& arr) {
//    size_t n = arr.size();
//
//    for (size_t i = 0; i < n - 1; ++i) {
//        size_t minIndex = i;
//
//        for (size_t j = i + 1; j < n; ++j) {
//            if (arr[j] < arr[minIndex]) {
//                minIndex = j;
//            }
//        }
//
//        std::swap(arr[i], arr[minIndex]);
//    }
//}
//
//int main() {
//    SetConsoleOutputCP(CP_UTF8);
//
//    std::vector<int> arr = {5, 2, 9, 3, 7, 1, 8, 4, 6};
//
//    selectionSort(arr);
//
//    std::cout << "Отсортированный массив: ";
//    for (int num : arr) {
//        std::cout << num << " ";
//    }
//    std::cout << std::endl;
//
//    return 0;
//}

//#13
//#include <iostream>
//#include <vector>
//#include <windows.h>
//
//int findMaxIndex(const std::vector<int>& arr) {
//    int maxIndex = 0;
//    for (size_t i = 1; i < arr.size(); ++i) {
//        if (arr[i] > arr[maxIndex]) {
//            maxIndex = i;
//        }
//    }
//    return maxIndex;
//}
//
//int findMinIndex(const std::vector<int>& arr) {
//    int minIndex = 0;
//    for (size_t i = 1; i < arr.size(); ++i) {
//        if (arr[i] < arr[minIndex]) {
//            minIndex = i;
//        }
//    }
//    return minIndex;
//}
//
//int sumBetweenMinMax(const std::vector<int>& arr) {
//    int maxIndex = findMaxIndex(arr);
//    int minIndex = findMinIndex(arr);
//
//    int start = std::min(maxIndex, minIndex);
//    int end = std::max(maxIndex, minIndex);
//
//    int sum = 0;
//    for (int i = start; i <= end; ++i) {
//        sum += arr[i];
//    }
//
//    return sum;
//}
//
//int main() {
//    SetConsoleOutputCP(CP_UTF8);
//
//    std::vector<int> arr = {3, 7, 1, 8, 4, 6, 2, 9, 5}; // Пример массива
//
//    int sum = sumBetweenMinMax(arr);
//
//    std::cout << "Сумма элементов между минимальным и максимальным: " << sum << std::endl;
//
//    return 0;
//}

//#14
//#include <iostream>
//#include <vector>
//#include <windows.h>
//
//int calculateY(const std::vector<int>& x) {
//    int m = x.size();
//    for (int i = 0; i < x.size(); ++i) {
//        if (x[i] < 0) {
//            m = i;
//            break;
//        }
//    }
//
//    int y = 0;
//    int term = 1;
//
//    for (int i = 0; i < m; ++i) {
//        term *= x[i];
//        y += term;
//    }
//
//    return y;
//}
//
//int main() {
//    SetConsoleOutputCP(CP_UTF8);
//
//    std::vector<int> x1 = {1, 2, 3, 4, 5}; // Пример массива без отрицательных элементов
//    std::vector<int> x2 = {1, 2, -3, 4, 5}; // Пример массива с отрицательным элементом
//
//    int y1 = calculateY(x1);
//    int y2 = calculateY(x2);
//
//    std::cout << "Для x1: y = " << y1 << std::endl;
//    std::cout << "Для x2: y = " << y2 << std::endl;
//
//    return 0;
//}

//#15
#include <iostream>
#include <vector>
#include <windows.h>

void cyclicShiftLeft(std::vector<int>& arr) {
    size_t n = arr.size();
    std::vector<int> temp(arr.begin(), arr.begin() + 2);

    for (size_t i = 0; i < n - 2; ++i) {
        arr[i] = arr[i + 2];
    }

    for (size_t i = n - 2, j = 0; i < n; ++i, ++j) {
        arr[i] = temp[j];
    }
}

int main() {
    SetConsoleOutputCP(CP_UTF8);

    std::vector<int> arr = {1, 2, 3, 4, 5, 6}; // Пример массива

    cyclicShiftLeft(arr);

    std::cout << "Массив после циклического сдвига влево: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
